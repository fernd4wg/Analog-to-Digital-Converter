# Analog-to-Digital-Converter
For this project, we were required to make an ADC using an Arduino as the controller.

# Project Requirements and Constraints
Specific Requirements
* ADC must be able to read voltages from 0-10 Vdc.
* Measured voltage must be displayed on a computer monitor up to 2 decimal places.
* The percent difference between the Arduino’s ADC and our ADC needs to be printed on the computer monitor.

# General Requirements
* Smaller than the palm of a hand 
* Minimal power supply usage 
* Shouldn’t use too many components 
* Relatively simple circuit

# Constraints
* The difference between the Arduino ADC and our ADC must be below 2% for all values
* Sourceable parts (All the parts we use must be accessible through the cage or the IEEE room)
* Response time should be less than 2 second(s)

# Background Research
When researching for the project we decided to focus most of our research on the specific circuit we would use to get our voltage value. We used potential maximum resolution, ease of use/implementation, maximum error, response time, and power usage as our criteria in our decision matrix to choose our circuit. The best choice for our needs ended up being the Ramp Generator. We were provided with a constant current ramp generator circuit but we opted to implement a RC Circuit to create a circuit similar to a ramp generator as it would end up being a lot simpler to implement and calculate for than a constant current ramp generator circuit.

# Building and Testing 
The initial creation of the circuit started with copying the schematic we made in TinkerCAD onto a breadboard. While ideally this should work in part, we immediately ran into issues with nearly every major component. The capacitor would not charge all the way, the transistor wouldn’t allow current through when given a current, and the Arduino wouldn’t read the comparator output how we wanted. We moved some of the inputs into the comparator around, and ended up frying it. We then had to take a step back and decided to rebuild the circuit while testing individual parts. We started by completely removing the transistor from the circuit, and just focused on getting the capacitor to charge. This was a struggle due to the transistor being part of the circuit, so we just tested the capacitor alone and got it to charge and discharge properly. Then came implementing the transistor. This came with its own set of problems due the transistor being controlled by the Arduino. Initially, the transistor was only changing the capacitor voltage by a couple hundred millivolts. We then made the decision to rewrite the Arduino code to just turn on the transistor for a set amount of time, and then turn it off for a set amount of time. This led to the same issue, so we knew that the transistor wasn’t the problem. We ended up modifying the circuit slightly by connecting the capacitor circuit directly to a ground on one side. This allowed for a proper charge and discharge of the capacitor. After we got those two components working together, we tried attaching the comparator to the circuit. Again, things went downhill with this comparator. While it didn’t burn out this time, it took a long time scouring the data sheet to figure out that we needed a pull-up resistor. We initially attached the 5V from the Arduino through the pull up resistor to the output of the comparator. Now we could see when the comparator switches because the voltage would change from approximately 5V to around 2.8V. Unfortunately, when the Arduino read these voltages through the digital pins, it read both the 5V and 2.8V as “high”. After a lot of debating and trying to figure out the issue, we ended up switching to a 3.3V voltage through the pull-up resistor and that allowed for the “high” to be 3.3V, which the Arduino also read as high, and the “low” to be around 1.3V, which the Arduino read as low. Finally after getting this component working, we tested a range of voltages to see if it would compare nicely and the arduino could read it. The final step was re-writing all the code. This began with attempting to implement the “pulseIn” function. Unfortunately, we were unable to get it to measure properly, so we ended up using a timer-like system with the “micros” function. Then we used the time with a bunch of mathematical calculations to calculate the actual voltage, and used a set of output and input points to apply a correction multiplier. Afterwards, we set up the Arduino ADC, also using a correction, and fixed the previous correction on our own ADC due to it being compared to the wrong input. Then we finished the code by printing out both ADC’s and the percentage difference between them. We tested with a range of voltages and were happy with the final result and went on to demo our ADC.

# Demo Results 
Though we did run into problems along the way to the final product our final product ended up with no noticeable errors. Our difference between the Arduino's ADC and our ADC was below one percent for nearly all values excluding those close to 0-1 V. An improvement we could've made was when it came to the code and our placement of when our transistor was allowing current through, which would have improved our accuracy overall. The change would have allowed for less code execution between checks on the comparator, and thus a more accurate reading of time and subsequent calculation.

# Overall Results
Our biggest problems stemmed from implementing the LM393 comparator chip. We had problems getting the output to a voltage where the Arduino would read low when the voltages did not match, and high when they did. We solved that problem by using a pull-up resistor, to help change the voltage where we needed it. The first voltage of 5V we used across said resistor still caused the same issue, so we used a lower voltage of 3.3V. There were also some smaller problems like the capacitor not charging properly, which stemmed from not having a proper common ground, and trying to use a burnt-out transistor.
One way we could have improved our design was to change how the Arduino waited for the capacitor to charge. In the code, we had a loop continually allowing the capacitor to charge until the capacitor was fully charged and then discharged. Although this wasn't a huge problem at our scale, only lowering the accuracy slightly, if we needed the circuit to update at a faster rate, it would be a significant enough problem. To improve the code we could have the command to charge the capacitor outside the while loop, then use the loop as a wait function until we get the high value from the comparator.
